# SPDX-FileCopyrightText: 2024 Alexandru Fikl <alexfikl@gmail.com>
# SPDX-License-Identifier: MIT

from __future__ import annotations

import logging
import pathlib
from dataclasses import dataclass
from typing import Any

import jinja2
import numpy as np
import rich.logging

log = logging.getLogger(pathlib.Path(__file__).stem)
log.setLevel(logging.ERROR)
log.addHandler(rich.logging.RichHandler())

TEMPLATE = """\
// SPDX-FileCopyrightText: 2024 Alexandru Fikl <alexfikl@gmail.com>
// SPDX-License-Identifier: MIT

// NOTE: This file has been generated by `scripts/generate-matrix-gallery.py`.
// DO NOT MODIFY it manually.

use nalgebra::{matrix, SMatrix};
use num::complex::Complex64;

macro_rules! c64 {
    ($re: literal) => {
        Complex64 { re: $re, im: 0.0 }
    };
}

pub struct Exhibit<const D: usize> {
    /// Matrix used in the iteration.
    pub mat: SMatrix<Complex64, D, D>,
    /// Bounding box for the points.
    pub upper_left: Complex64,
    pub lower_right: Complex64,
}

((( for ex in exhibits )))
#[allow(dead_code)]
pub const ((* ex.identifier *)): Exhibit<((* ex.size *))> = Exhibit::<((* ex.size *))> {
    mat: matrix![
        ((* ex.stringified_mat | indent(width=8) *))
    ],
    upper_left: Complex64 {
        re: ((* ex.upper_left.real *)),
        im: ((* ex.upper_left.imag *)),
    },
    lower_right: Complex64 {
        re: ((* ex.lower_right.real *)),
        im: ((* ex.lower_right.imag *)),
    },
};
((( endfor )))
"""


@dataclass(frozen=True)
class Exhibit:
    name: str
    """Name of the exihibit (should be a valid Rust identifier)."""
    mat: np.ndarray[Any, Any]
    """Matrix for the Netbrot set."""

    upper_left: complex
    """Upper left corner of the rendering bounding box."""
    lower_right: complex
    """Lower right corner of the rendering bounding box."""

    def __post_init__(self) -> None:
        assert self.mat.ndim == 2
        assert self.mat.shape[0] == self.mat.shape[1]

    @property
    def identifier(self) -> str:
        return self.name.upper()

    @property
    def size(self) -> int:
        return self.mat.shape[0]

    @property
    def stringified_mat(self) -> str:
        n = self.size
        return "\n".join(
            "{};".format(
                ", ".join(f"c64!({float(self.mat[i, j])!r})" for j in range(n))
            )
            for i in range(n)
        )


DEFAULT_EXHIBITS = [
    Exhibit(
        name="EXHIBIT_1_2X2_FULL",
        mat=np.array([[1.0, 0.8], [1.0, -0.5]]),
        upper_left=complex(-0.9, 0.6),
        lower_right=complex(0.4, -0.6),
    ),
    Exhibit(
        name="EXHIBIT_2_2X2_FULL",
        mat=np.array([[1.0, 1.0], [0.0, 1.0]]),
        upper_left=complex(-0.9, 0.6),
        lower_right=complex(0.4, 0.6),
    ),
    Exhibit(
        name="EXHIBIT_3_3X3_FULL",
        mat=np.array([[1.0, 0.0, 0.0], [-1.0, 1.0, 0.0], [1.0, 1.0, -1.0]]),
        upper_left=complex(-1.25, 0.75),
        lower_right=complex(0.5, -0.75),
    ),
    Exhibit(
        name="EXHIBIT_3_3X3_BABY",
        mat=np.array([[1.0, 0.0, 0.0], [-1.0, 1.0, 0.0], [1.0, 1.0, -1.0]]),
        upper_left=complex(-1.025, 0.025),
        lower_right=complex(-0.975, -0.025),
    ),
]


def make_jinja_env() -> jinja2.Environment:
    env = jinja2.Environment(
        block_start_string="(((",
        block_end_string=")))",
        variable_start_string="((*",
        variable_end_string="*))",
        comment_start_string="((=",
        comment_end_string="=))",
        autoescape=True,
    )

    return env


def main(
    infile: pathlib.Path | None = None,
    outfile: pathlib.Path | None = None,
    *,
    overwrite: bool = False,
) -> int:
    if infile is not None and not infile.exists():
        log.error("File does not exist: '%s'", infile)
        return 1

    if not overwrite and outfile is not None and outfile.exists():
        log.error("Output file exists (use --overwrite): '%s'.", outfile)
        return 1

    exhibits = DEFAULT_EXHIBITS.copy()

    if infile:
        data = np.load(infile)
        structural_connection_matrices = data["structural_connection_matrices"]

        for i in range(structural_connection_matrices.shape[0]):
            mat = structural_connection_matrices[i]
            n = mat.shape[0]
            exhibits.append(
                Exhibit(
                    name=f"EXHIBIT_{i}_{n}x{n}_STRCTURURAL",
                    mat=mat,
                    upper_left=complex(-3.75, 2.5),
                    lower_right=complex(1.25, -2.5),
                )
            )

    env = make_jinja_env()
    result = env.from_string(TEMPLATE).render(exhibits=exhibits)

    if outfile:
        with open(outfile, "w", encoding="utf-8") as outf:
            outf.write(result)
    else:
        print(result)

    return 0


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser()
    parser.add_argument("-i", "--infile", type=pathlib.Path, default=None)
    parser.add_argument("-o", "--outfile", type=pathlib.Path, default=None)
    parser.add_argument(
        "--overwrite",
        action="store_true",
        help="overwrite existing files",
    )
    parser.add_argument(
        "-q",
        "--quiet",
        action="store_true",
        help="only show error messages",
    )
    args = parser.parse_args()

    if not args.quiet:
        log.setLevel(logging.INFO)

    raise SystemExit(
        main(
            args.infile,
            args.outfile,
            overwrite=args.overwrite,
        )
    )
