# SPDX-FileCopyrightText: 2024 Alexandru Fikl <alexfikl@gmail.com>
# SPDX-License-Identifier: MIT

from __future__ import annotations

import logging
import pathlib
from contextlib import suppress

import numpy as np
import rich.logging

log = logging.getLogger(pathlib.Path(__file__).stem)
log.setLevel(logging.ERROR)
log.addHandler(rich.logging.RichHandler())

SCRIPT_PATH = pathlib.Path(__file__)
SCRIPT_LONG_HELP = f"""\
This script performs basic edge detection on a series of input images. For each
image the script outputs a `{{filename}}-edge.{{ext}}` file containing the raw
edge detection results.

All the edge detection results are overlapped to create the main result image.
The images are plotted on a given extent of physical coordinates. Use the
`--extent` flag to give the `(left, right, bottom, top)` coordinates of the extent.

This is meant to be used on the images generated by the main `netbrot` executable.
All the images are expected to be the same size. If multiple sized images are
available, just call the script multiple times!

Example:

    > {SCRIPT_PATH.name} --extent -1 1 -1 1 --outfile edges.png images/*.png
"""

DEFAULT_EXTENT = (-10.25, 4.25, -6.0, 6.0)


def set_recommended_matplotlib() -> None:
    import matplotlib.pyplot as mp

    with suppress(ImportError):
        import scienceplots  # noqa: F401

        mp.style.use(["science", "ieee"])

    mp.style.use(SCRIPT_PATH.parent / "default.mplstyle")


# {{{ main


def main(
    filenames: list[pathlib.Path],
    outfile: pathlib.Path | None,
    *,
    extent: tuple[float, float, float, float] | None = None,
    overwrite: bool = False,
) -> int:
    try:
        import matplotlib.colors as mc
        import matplotlib.pyplot as mp
    except ImportError:
        log.error("'matplotlib' package not found.")
        return 1

    try:
        import cv2
    except ImportError:
        log.error("'cv2' package not found.")
        return 1

    if not overwrite and outfile is not None and outfile.exists():
        log.error("Output file exists (use --overwrite): '%s'.", outfile)
        return 1

    if extent is None:
        extent = DEFAULT_EXTENT

    from itertools import cycle

    set_recommended_matplotlib()

    fig = mp.figure()
    ax = fig.gca()
    colors = cycle(mp.rcParams["axes.prop_cycle"].by_key()["color"])

    ret = 0
    shape = None

    for filename in filenames:
        if not filename.exists():
            ret = 1
            log.error("File does not exist: '%s'.", filename)
            continue

        # turn to grayscale
        img = cv2.imread(filename)
        if shape is None:
            shape = img.shape[:2]
        elif shape != img.shape[:2]:
            log.error(
                "Expected size %dx%d but image '%s' has size %dx%d.",
                *shape,
                filename,
                *img.shape[:2],
            )
            return 1

        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

        # really clip the values
        gray[gray > 10] = 255
        gray[gray <= 10] = 0

        # edge detect
        edges = gray
        edges = cv2.Canny(gray, 100, 200)
        edges = 255 - edges

        output = filename.with_stem(f"{filename.stem}-edge")
        cv2.imwrite(output, edges)
        log.info("Saving edge detected image: '%s'", output)

        edges = 255 - edges
        r, g, b = mc.to_rgb(next(colors))
        R = np.minimum(255, edges * r).astype(edges.dtype)
        G = np.minimum(255, edges * g).astype(edges.dtype)
        B = np.minimum(255, edges * b).astype(edges.dtype)
        colored = cv2.merge((B, G, R, edges))
        ax.imshow(colored, origin="lower", extent=extent)

    if outfile is None:
        outfile = pathlib.Path("result")

    if not outfile.suffix:
        ext = mp.rcParams["savefig.format"]
        outfile = outfile.with_suffix(f".{ext}")

    ax.set_xlabel("$x$")
    ax.set_ylabel("$y$")
    fig.savefig(outfile)
    log.info("Saving group image: '%s'.", outfile)

    return ret


# }}}


if __name__ == "__main__":
    import argparse

    class HelpFormatter(
        argparse.ArgumentDefaultsHelpFormatter,
        argparse.RawDescriptionHelpFormatter,
    ):
        pass

    parser = argparse.ArgumentParser(
        formatter_class=HelpFormatter,
        description=SCRIPT_LONG_HELP,
    )
    parser.add_argument("filenames", nargs="+", type=pathlib.Path)
    parser.add_argument("-o", "--outfile", type=pathlib.Path, default=None)
    parser.add_argument(
        "--extent",
        nargs=4,
        type=float,
        default=DEFAULT_EXTENT,
        help="Extent limits (left, right, bottom, top) passed to imshow",
    )
    parser.add_argument(
        "--overwrite",
        action="store_true",
        help="Overwrite existing files",
    )
    parser.add_argument(
        "-q",
        "--quiet",
        action="store_true",
        help="Only show error messages",
    )
    args = parser.parse_args()

    if not args.quiet:
        log.setLevel(logging.INFO)

    raise SystemExit(
        main(
            args.filenames,
            args.outfile,
            extent=args.extent,
            overwrite=args.overwrite,
        )
    )
